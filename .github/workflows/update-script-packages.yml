name: Update via scripts

on:
  workflow_dispatch:
  schedule:
    - cron: 7 0/4 * * *
  push:
    branches:
      - main
    paths:
      - .github/workflows/update-script-packages.yml
      - Scripts/Packages/*

jobs:
  # Job 1: Generate manifests for all packages
  generate-manifest:
    name: Generate ${{ matrix.PackageName }}
    runs-on: windows-2025
    environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Test' }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          - PackageName: "MongoDB.Server"
            WebsiteURL: "https://www.mongodb.com/try/download/community"      
          - PackageName: "MongoDB.MongoDBCLI"
            WebsiteURL: "https://www.mongodb.com/try/download/tools"
          - PackageName: "MongoDB.Shell"
            WebsiteURL: "https://www.mongodb.com/try/download/tools"     
          - PackageName: "MongoDB.MongoDBAtlasCLI"
            WebsiteURL: "https://www.mongodb.com/try/download/tools"
            With: wingetcreate
          - PackageName: "MongoDB.DatabaseTools"
            WebsiteURL: "https://www.mongodb.com/try/download/tools" 
          - PackageName: "MongoDB.Compass.Full"
            WebsiteURL: "https://www.mongodb.com/try/download/tools"
          - PackageName: "MongoDB.Compass.Isolated"
            WebsiteURL: "https://www.mongodb.com/try/download/tools"
          - PackageName: "MongoDB.Compass.Readonly"
            WebsiteURL: "https://www.mongodb.com/try/download/tools"
          - PackageName: "Glarysoft.GlaryUtilities"
            WebsiteURL: "https://download.glarysoft.com/gusetup.exe"
            With: WinGetCreate
          - PackageName: "GitButler.GitButler"
            WebsiteURL: "https://app.gitbutler.com/downloads/release/windows/x86_64/msi"   
          - PackageName: "FlipperDevicesInc.qFlipper"
            WebsiteURL: "https://update.flipperzero.one/qFlipper/directory.json"
            With: WinGetCreate
          - PackageName: "Loupedeck.Loupedeck"
          - PackageName: "StrawberryPerl.StrawberryPerl"
            WebsiteURL: "https://github.com/StrawberryPerl/Perl-Dist-Strawberry"
          - PackageName: "Fork.Fork"
            WebsiteURL: "https://fork.dev"
          - PackageName: "Egnyte.EgnyteWebEdit"
            WebsiteURL: "https://egnyte-cdn.egnyte.com/webedit/win/en-us/latest/EgnyteWebEdit.msi"
          - PackageName: "cURL.cURL"
            WebsiteURL: "https://curl.se/windows/"
          - PackageName: "Bitwarden.CLI"
            WebsiteURL: "https://github.com/bitwarden/clients"
          - PackageName: "SublimeHQ.SublimeMerge"
            WebsiteURL: "https://www.sublimemerge.com/download"
          - PackageName: "Bandisoft.Bandizip"
          - PackageName: "wire.wire"
          - PackageName: "glueckkanja.KONNEKT"
          - PackageName: "Ghisler.TotalCommander"
          - PackageName: "Jellyfin.Server"
          - PackageName: "Amazon.Kindle"

    steps:
      - name: Checkout
        uses: actions/checkout@v6
      
      - name: Generate manifest
        id: generate
        env:
          GITHUB_TOKEN: ${{ secrets.WINGET_PAT }}
          WINGET_PKGS_FORK_REPO: ${{ vars.WINGET_PKGS_FORK_REPO }}
          WebsiteURL: ${{ matrix.WebsiteURL }}
          PackageName: ${{ matrix.PackageName }}
          With: ${{ matrix.With }}
          Submit: "false"
          IsTemplateUpdate: "true"
        run: |
          # Import the module
          Import-Module .\modules\WingetMaintainerModule\WingetMaintainerModule.psd1 -Force
          
          # Load HtmlAgilityPack if needed
          $htmlAgilityPath = ".\libraries\HtmlAgilityPack\HtmlAgilityPack.dll"
          if (Test-Path $htmlAgilityPath) {
            Add-Type -Path $htmlAgilityPath
          }
          
          # Call the update script - now returns result instead of submitting
          .\scripts\Update-Package.ps1
      
      - name: Export manifest to job summary
        if: steps.generate.outputs.generated == 'true'
        shell: pwsh
        run: |
          Import-Module .\modules\WingetMaintainerModule\WingetMaintainerModule.psd1 -Force
          
          Export-ManifestToJobSummary `
            -ManifestPath "${{ steps.generate.outputs.manifest-path }}" `
            -PackageId "${{ matrix.PackageName }}" `
            -Version "${{ steps.generate.outputs.version }}"
      
      - name: Upload manifest artifact
        if: steps.generate.outputs.generated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: manifest__${{ matrix.PackageName }}__${{ steps.generate.outputs.version }}
          path: ${{ steps.generate.outputs.manifest-path }}
          retention-days: 7
          if-no-files-found: error

  # Job 2: Collect successful manifest generations into a dynamic matrix
  collect-generated:
    name: Collect Generated Manifests
    needs: generate-manifest
    runs-on: ubuntu-latest
    if: always() && needs.generate-manifest.result != 'cancelled'
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    
    steps:
      - name: Download all manifest artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: manifest__*
          path: ./manifests
      
      - name: Build dynamic matrix from artifacts
        id: set-matrix
        shell: pwsh
        run: |
          $manifestsDir = "./manifests"
          $packages = @()
          
          if (Test-Path $manifestsDir) {
            # Each artifact folder is named manifest__{PackageName}__{version}
            $artifactFolders = Get-ChildItem -Path $manifestsDir -Directory
            
            foreach ($folder in $artifactFolders) {
              # Parse folder name: manifest__{PackageName}__{version}
              if ($folder.Name -match '^manifest__(.+)__(.+)$') {
                $packageName = $Matches[1]
                $version = $Matches[2]
                $packages += @{ PackageName = $packageName; version = $version }
                Write-Host "Found: $packageName @ $version"
              }
            }
          }
          
          # Always output matrix - empty include array will auto-skip downstream jobs
          # @($packages) forces array even with single item
          $matrix = @{ include = @($packages) } | ConvertTo-Json -Compress -Depth 3
          Add-Content -Path $env:GITHUB_OUTPUT -Encoding utf8 -Value "matrix=$matrix"
          Write-Host "Matrix: $matrix"

  # Job 3: Validate and test manifests in sandbox (self-hosted runner with Windows Sandbox)
  # Uses dynamic matrix - only runs for packages that generated manifests
  validate-and-test:
    name: Validate ${{ matrix.PackageName }}
    needs: collect-generated
    runs-on: [self-hosted, Windows, X64]
    if: always() && needs.collect-generated.result == 'success'
    
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.collect-generated.outputs.matrix) }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      
      - name: Resolve Sandbox Log Paths
        id: resolve_logs
        shell: pwsh
        run: |
          $logsRoot = Join-Path $env:LOCALAPPDATA "Packages\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe\SandboxTest\Logs"
          "sandbox_logs=$logsRoot" >> $env:GITHUB_OUTPUT
      
      - name: Download manifest artifact
        uses: actions/download-artifact@v4
        with:
          name: manifest__${{ matrix.PackageName }}__${{ matrix.version }}
          path: ./downloaded-manifests
      
      - name: Set manifest path
        id: manifest
        shell: pwsh
        run: |
          $yamlFiles = Get-ChildItem -Path "./downloaded-manifests" -Filter "*.yaml" -Recurse
          $manifestPath = ($yamlFiles | Select-Object -First 1).DirectoryName
          Write-Host "Manifest path: $manifestPath"
          "path=$manifestPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
      
      - name: Export manifest to job summary
        shell: pwsh
        run: |
          Import-Module .\modules\WingetMaintainerModule\WingetMaintainerModule.psd1 -Force
          
          Export-ManifestToJobSummary `
            -ManifestPath "${{ steps.manifest.outputs.path }}" `
            -PackageId "${{ matrix.PackageName }}" `
            -Version "${{ matrix.version }}"
      
      - name: Run content validation
        id: content-validation
        shell: pwsh
        run: |
          $manifestPath = "${{ steps.manifest.outputs.path }}"
          
          Write-Host "Running content validation for: $manifestPath"
          
          & .\Scripts\validation\Test-ManifestContent.ps1 -ManifestPath $manifestPath
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -eq 0) {
            "passed=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            "passed=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit $exitCode
          }
      
      - name: Run sandbox validation
        id: sandbox-validation
        if: steps.content-validation.outputs.passed == 'true'
        timeout-minutes: 30
        shell: pwsh
        env:
          WINGET_PKGS_GITHUB_TOKEN: ${{ secrets.WINGET_PAT }}
        run: |
          $manifestPath = "${{ steps.manifest.outputs.path }}"
          
          Write-Host "Running sandbox validation for: $manifestPath"
          
          & .\Scripts\validation\Test-Manifest-Sandbox.ps1 -ManifestPath $manifestPath
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -eq 0) {
            "passed=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            "passed=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            exit $exitCode
          }
      
      - name: Upload sandbox logs
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: sandbox-logs-${{ matrix.PackageName }}
          path: ${{ steps.resolve_logs.outputs.sandbox_logs }}
          retention-days: 7
          if-no-files-found: ignore
      
      - name: Set validation result
        id: validation
        if: always()
        shell: pwsh
        run: |
          $contentPassed = "${{ steps.content-validation.outputs.passed }}"
          $sandboxPassed = "${{ steps.sandbox-validation.outputs.passed }}"
          
          if ($contentPassed -eq "true" -and $sandboxPassed -eq "true") {
            Write-Host "All validations passed!" -ForegroundColor Green
            "passed=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            Write-Host "Validation failed" -ForegroundColor Red
            Write-Host "  Content: $contentPassed"
            Write-Host "  Sandbox: $sandboxPassed"
            "passed=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
      
      - name: Upload validation result marker
        if: always() && steps.validation.outputs.passed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: validated__${{ matrix.PackageName }}__${{ matrix.version }}
          path: ${{ steps.manifest.outputs.path }}
          retention-days: 1
          if-no-files-found: error

  # Job 4: Collect validated packages into matrix for PR submission
  collect-validated:
    name: Collect Validated Packages
    needs: [collect-generated, validate-and-test]
    runs-on: ubuntu-latest
    if: always() && needs.validate-and-test.result != 'cancelled' && vars.SUBMIT_PR == 'true'
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_packages: ${{ steps.set-matrix.outputs.has_packages }}
    
    steps:
      - name: Download validated artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: validated__*
          path: ./validated
      
      - name: Build matrix from validated packages
        id: set-matrix
        shell: pwsh
        run: |
          $validatedDir = "./validated"
          $packages = @()
          
          if (Test-Path $validatedDir) {
            $artifactFolders = Get-ChildItem -Path $validatedDir -Directory
            
            foreach ($folder in $artifactFolders) {
              if ($folder.Name -match '^validated__(.+)__(.+)$') {
                $packageName = $Matches[1]
                $version = $Matches[2]
                $packages += @{ PackageName = $packageName; version = $version }
                Write-Host "Validated: $packageName @ $version"
              }
            }
          }
          
          $hasPackages = $packages.Count -gt 0
          $matrix = @{ include = @($packages) } | ConvertTo-Json -Compress -Depth 3
          Add-Content -Path $env:GITHUB_OUTPUT -Encoding utf8 -Value "matrix=$matrix"
          Add-Content -Path $env:GITHUB_OUTPUT -Encoding utf8 -Value "has_packages=$hasPackages"
          Write-Host "Matrix: $matrix"
          Write-Host "Has packages: $hasPackages"

  # Job 5: Submit PRs for validated packages
  # Uses dynamic matrix from collect-validated - only runs for packages that passed validation
  submit-pr:
    name: Submit ${{ matrix.PackageName }}
    needs: [collect-validated]
    runs-on: windows-2025
    if: always() && needs.collect-validated.result == 'success' && needs.collect-validated.outputs.has_packages == 'true'
    environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Test' }}
    
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.collect-validated.outputs.matrix) }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      
      - name: Download manifest artifact
        uses: actions/download-artifact@v4
        with:
          name: validated__${{ matrix.PackageName }}__${{ matrix.version }}
          path: ./downloaded-manifests
      
      - name: Set manifest path
        id: manifest
        shell: pwsh
        run: |
          $yamlFiles = Get-ChildItem -Path "./downloaded-manifests" -Filter "*.yaml" -Recurse
          $manifestPath = ($yamlFiles | Select-Object -First 1).DirectoryName
          Write-Host "Manifest path: $manifestPath"
          "path=$manifestPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
      
      - name: Submit PR
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.WINGET_PAT }}
        run: |
          Import-Module .\modules\WingetMaintainerModule\WingetMaintainerModule.psd1 -Force
          
          $result = Submit-WingetPackage `
            -ManifestPath "${{ steps.manifest.outputs.path }}" `
            -PackageId "${{ matrix.PackageName }}" `
            -Version "${{ matrix.version }}"
          
          if ($result.Success) {
            Write-Host "PR submitted successfully!" -ForegroundColor Green
            if ($result.PrUrl) {
              Write-Host "PR URL: $($result.PrUrl)"
              
              # Add to job summary
              "## :rocket: PR Submitted" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
              "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
              "**Package:** ${{ matrix.PackageName }}" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
              "**Version:** ${{ matrix.version }}" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
              "**PR:** $($result.PrUrl)" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
            }
          } else {
            Write-Host "Failed to submit PR: $($result.Error)" -ForegroundColor Red
            exit 1
          }

  # Job 6: Notify on failure
  notify-failure:
    name: Notify Failure
    needs: [generate-manifest, collect-generated, validate-and-test, collect-validated, submit-pr]
    runs-on: ubuntu-latest
    if: always() && failure() && vars.NTFY_URL != ''
    
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      
      - name: Send failure notification
        shell: pwsh
        run: |
          $runUrl = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          $body = @{
            topic    = "${{ vars.NTFY_TOPIC }}"
            title    = "Winget Package Update Failed"
            message  = "Workflow: ${{ github.workflow }}`nRun: $runUrl`n`nOne or more packages failed validation or submission."
            priority = 4
            tags     = @("x", "package", "warning")
            click    = $runUrl
          } | ConvertTo-Json
          
          try {
            Invoke-RestMethod -Uri "${{ vars.NTFY_URL }}/${{ vars.NTFY_TOPIC }}" `
              -Method Post `
              -ContentType 'application/json' `
              -Body $body
            Write-Host "Notification sent successfully"
          } catch {
            Write-Warning "Failed to send notification: $_"
          }


